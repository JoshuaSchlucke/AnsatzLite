module main // must be named same as the file!

import args
import result
import exception
import list
import src/cli/parse
import src/cli/validate
import src/qaoa/types
import src/qaoa/effects
import src/handlers/statevector
import src/handlers/shot_based
import src/handlers/noise
import src/handlers/sampling
import src/handlers/pretty_print
import src/handlers/pretty_sampling
import src/optimize/basic
import src/problems/graph
import src/problems/maxcut
import src/problems/mis
import src/problems/vertex_cover
import src/problems/sat

// Build layers from parameter lists.

def buildLayers(gs: List[Double], bs: List[Double]): List[Layer] = (gs, bs) match {
  case (Nil(), Nil()) => Nil()
  case (Cons(g, gs1), Cons(b, bs1)) => Cons(layer(g, b), buildLayers(gs1, bs1))
  case _ => Nil()
}

def layersFromParams(params: List[Double], p: Int): List[Layer] = {
  val gs = list::take(params, p)
  val bs = list::drop(params, p)
  buildLayers(gs, bs)
}

def showDoubleList(xs: List[Double]): String = {
  var out = "["
  var first = true
  xs.foreach { v =>
    if (first) {
      out = out ++ v.show
      first = false
    } else {
      out = out ++ ", " ++ v.show
    }
  }
  out ++ "]"
}

def optimizeLayers(cfg: Config) { objective: Ansatz => Double }: List[Layer] = {
  def evalParams(params: List[Double]): Double = {
    val layers = layersFromParams(params, cfg.p)
    val a = ansatz(layers)
    objective(a)
  }

  cfg.opt match {
    case "grid" =>
      val res = gridSearch(cfg.p, cfg.optSteps, cfg.gammaMin, cfg.gammaMax, cfg.betaMin, cfg.betaMax) { evalParams }
      if (cfg.optVerbose) {
        val gs = list::take(res.params, cfg.p)
        val bs = list::drop(res.params, cfg.p)
        println("opt=grid best=" ++ res.value.show ++ " gammas=" ++ showDoubleList(gs) ++ " betas=" ++ showDoubleList(bs))
      }
      layersFromParams(res.params, cfg.p)
    case "random" =>
      val res = randomSearch(cfg.p, cfg.optSteps, cfg.seed, cfg.gammaMin, cfg.gammaMax, cfg.betaMin, cfg.betaMax) { evalParams }
      if (cfg.optVerbose) {
        val gs = list::take(res.params, cfg.p)
        val bs = list::drop(res.params, cfg.p)
        println("opt=random best=" ++ res.value.show ++ " gammas=" ++ showDoubleList(gs) ++ " betas=" ++ showDoubleList(bs))
      }
      layersFromParams(res.params, cfg.p)
    case "local" =>
      val init =
        if (cfg.optInit == "grid")
          gridSearch(cfg.p, cfg.optSteps, cfg.gammaMin, cfg.gammaMax, cfg.betaMin, cfg.betaMax) { evalParams }
        else
          randomSearch(cfg.p, cfg.optSteps, cfg.seed, cfg.gammaMin, cfg.gammaMax, cfg.betaMin, cfg.betaMax) { evalParams }
      val res = localSearch(cfg.p, init.params, cfg.localSteps, cfg.localStep, cfg.localDecay, cfg.gammaMin, cfg.gammaMax, cfg.betaMin, cfg.betaMax) { evalParams }
      if (cfg.optVerbose) {
        val initGs = list::take(init.params, cfg.p)
        val initBs = list::drop(init.params, cfg.p)
        println("opt=local init=" ++ cfg.optInit ++ " value=" ++ init.value.show ++ " gammas=" ++ showDoubleList(initGs) ++ " betas=" ++ showDoubleList(initBs))
        val gs = list::take(res.params, cfg.p)
        val bs = list::drop(res.params, cfg.p)
        println("opt=local best=" ++ res.value.show ++ " gammas=" ++ showDoubleList(gs) ++ " betas=" ++ showDoubleList(bs))
      }
      layersFromParams(res.params, cfg.p)
    case _ => buildLayers(cfg.gammas, cfg.betas)
  }
}


def runWithBackend(cfg: Config) { program: () => Double / {prepare, cost, costEdge, costPredicate, mixer, expect} }: Double =
  cfg.backend match {
    case "statevector" => withStatevector { program() }
    case "shots" => withShots(cfg.numShots, cfg.seed) { program() }
    case "noisy" => withNoisyStatevector(cfg.noiseProb, cfg.seed) { program() }
    case _ => 0.0
  }

def runAndPrint(cfg: Config) { program: () => Double / {prepare, cost, costEdge, costPredicate, mixer, expect} }: Unit =
  cfg.backend match {
    case "sampling" =>
      val samples = withSampling(cfg.numShots, cfg.seed) { program() }
      samples.foreach { s => println(s) }
    case "pretty-sample" =>
      val ps = withPrettySampling(cfg.numShots, cfg.seed) { program() }
      println("pretty:")
      ps.lines.foreach { l => println(l) }
      println("samples:")
      ps.samples.foreach { s => println(s) }
    case "pretty+sample" =>
      val ps = withPrettySampling(cfg.numShots, cfg.seed) { program() }
      println("pretty:")
      ps.lines.foreach { l => println(l) }
      println("samples:")
      ps.samples.foreach { s => println(s) }
    case "pretty" =>
      val lines = withPrettyPrint { program() }
      lines.foreach { l => println(l) }
    case _ =>
      val out = runWithBackend(cfg) { program() }
      println("result=" ++ out.show)
  }

// MVP entrypoint: parse args and run a problem instance.

def main() = {
  val argsList = args::commandLineArgs()
  val cfgRes = result[Config, WrongFormat] { validateConfig(parseArgs(argsList)) }

  cfgRes match {
    case Success(cfg) =>
      cfg.problem match {
        case "maxcut" =>
          val g = tinyGraph()
          val layers =
            if (cfg.opt == "none") buildLayers(cfg.gammas, cfg.betas)
            else optimizeLayers(cfg) { a => runWithBackend(cfg) { () => executeMaxCut(a, g) } }
          val a = ansatz(layers)
          runAndPrint(cfg) { () => executeMaxCut(a, g) }
        case "mis" =>
          val g = tinyGraph()
          val layers =
            if (cfg.opt == "none") buildLayers(cfg.gammas, cfg.betas)
            else optimizeLayers(cfg) { a => runWithBackend(cfg) { () => executeMIS(a, g) } }
          val a = ansatz(layers)
          runAndPrint(cfg) { () => executeMIS(a, g) }
        case "vertex-cover" =>
          val g = tinyGraph()
          val layers =
            if (cfg.opt == "none") buildLayers(cfg.gammas, cfg.betas)
            else optimizeLayers(cfg) { a => runWithBackend(cfg) { () => executeVertexCover(a, g) } }
          val a = ansatz(layers)
          runAndPrint(cfg) { () => executeVertexCover(a, g) }
        case "sat" =>
          val fRes = result[Formula, WrongFormat] { formulaFromName(cfg.formula) }
          fRes match {
            case Success(f) =>
              val layers =
                if (cfg.opt == "none") buildLayers(cfg.gammas, cfg.betas)
                else optimizeLayers(cfg) { a => runWithBackend(cfg) { () => executeMaxSat(a, f) } }
              val a = ansatz(layers)
              runAndPrint(cfg) { () => executeMaxSat(a, f) }
            case Error(_, msg) => println("error: " ++ msg)
          }
        case _ => ()
      }
    case Error(_, msg) =>
      println("error: " ++ msg)
  }
}
