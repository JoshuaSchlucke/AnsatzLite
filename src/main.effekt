module main // must be named same as the file!

import args
import result
import exception
import src/cli/parse
import src/cli/validate
import src/qaoa/types
import src/qaoa/effects
import src/handlers/statevector
import src/handlers/shot_based
import src/handlers/noise
import src/handlers/sampling
import src/handlers/pretty_print
import src/handlers/pretty_sampling
import src/problems/graph
import src/problems/maxcut
import src/problems/mis
import src/problems/vertex_cover
import src/problems/sat

// Build layers from parameter lists.

def buildLayers(gs: List[Double], bs: List[Double]): List[Layer] = (gs, bs) match {
  case (Nil(), Nil()) => Nil()
  case (Cons(g, gs1), Cons(b, bs1)) => Cons(layer(g, b), buildLayers(gs1, bs1))
  case _ => Nil()
}


def runWithBackend(cfg: Config) { program: () => Double / {prepare, cost, costEdge, costPredicate, mixer, expect} }: Double =
  cfg.backend match {
    case "statevector" => withStatevector { program() }
    case "shots" => withShots(cfg.numShots, cfg.seed) { program() }
    case "noisy" => withNoisyStatevector(cfg.noiseProb, cfg.seed) { program() }
    case _ => 0.0
  }

def runAndPrint(cfg: Config) { program: () => Double / {prepare, cost, costEdge, costPredicate, mixer, expect} }: Unit =
  cfg.backend match {
    case "sampling" =>
      val samples = withSampling(cfg.numShots, cfg.seed) { program() }
      samples.foreach { s => println(s) }
    case "pretty-sample" =>
      val ps = withPrettySampling(cfg.numShots, cfg.seed) { program() }
      println("pretty:")
      ps.lines.foreach { l => println(l) }
      println("samples:")
      ps.samples.foreach { s => println(s) }
    case "pretty+sample" =>
      val ps = withPrettySampling(cfg.numShots, cfg.seed) { program() }
      println("pretty:")
      ps.lines.foreach { l => println(l) }
      println("samples:")
      ps.samples.foreach { s => println(s) }
    case "pretty" =>
      val lines = withPrettyPrint { program() }
      lines.foreach { l => println(l) }
    case _ =>
      val out = runWithBackend(cfg) { program() }
      println("result=" ++ out.show)
  }

// MVP entrypoint: parse args and run a problem instance.

def main() = {
  val argsList = args::commandLineArgs()
  val cfgRes = result[Config, WrongFormat] { validateConfig(parseArgs(argsList)) }

  cfgRes match {
    case Success(cfg) =>
      val layers = buildLayers(cfg.gammas, cfg.betas)
      val a = ansatz(layers)

      cfg.problem match {
        case "maxcut" =>
          val g = tinyGraph()
          runAndPrint(cfg) { () => executeMaxCut(a, g) }
        case "mis" =>
          val g = tinyGraph()
          runAndPrint(cfg) { () => executeMIS(a, g) }
        case "vertex-cover" =>
          val g = tinyGraph()
          runAndPrint(cfg) { () => executeVertexCover(a, g) }
        case "sat" =>
          val fRes = result[Formula, WrongFormat] { formulaFromName(cfg.formula) }
          fRes match {
            case Success(f) => runAndPrint(cfg) { () => executeMaxSat(a, f) }
            case Error(_, msg) => println("error: " ++ msg)
          }
        case _ => ()
      }
    case Error(_, msg) =>
      println("error: " ++ msg)
  }
}
