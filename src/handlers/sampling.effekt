module src/handlers/sampling

import random
import array
import list
import src/lib
import src/handlers/statevector
import src/qaoa/effects

// Sampling handler that returns measured bitstrings (as strings).


def sampleIndex(state: Array[Complex]): Int / random = {
  val r = random::randomDouble()
  val size = state.size
  var acc = 0.0
  var chosen = -1
  var i = 0
  while (i < size) {
    acc = acc + abs2(getAt(state, i))
    if (chosen == -1 && r <= acc) {
      chosen = i
    }
    i = i + 1
  }
  if (chosen == -1) size - 1 else chosen
}


def bitsToString(value: Int, qubits: Int): String = {
  var out = ""
  var i = qubits - 1
  while (i >= 0) {
    val bit = bitwiseAnd(bitwiseShr(value, i), 1)
    out = out ++ (if (bit == 0) "0" else "1")
    i = i - 1
  }
  out
}


def sampleBitstrings(state: Array[Complex], qubits: Int, shots: Int): List[String] / random = {
  var acc: List[String] = Nil()
  var i = 0
  while (i < shots) {
    val idx = sampleIndex(state)
    acc = Cons(bitsToString(idx, qubits), acc)
    i = i + 1
  }
  acc.reverse
}

// Returns the sampled bitstrings; ignores expectation values.

def withSampling(shots: Int, seed: Int) { prog: => Double / {prepare, cost, costEdge, costPredicate, mixer, expect} }: List[String] = {
  var _out = 0.0
  var samples: List[String] = Nil()
  seed.minstd {
    var qubits = 0
    var state: Array[Complex] = array(0, zero())

    def run(): Double = try { prog() }
      with prepare { n =>
        qubits = n
        state = plusState(n)
        resume(())
      }
      with cost { gamma =>
        applyRzAll(state, qubits, gamma)
        resume(())
      }
      with costEdge { (gamma, u, v, w) =>
        applyZZ(state, u, v, gamma * w)
        resume(())
      }
      with costPredicate { gamma =>
        resume { {predicate} =>
          applyPredicatePhase(state, gamma) { predicate }
          ()
        }
      }
      with mixer { beta =>
        applyRxAll(state, qubits, beta)
        resume(())
      }
      with expect {
        resume { {value} =>
          val newSamples = sampleBitstrings(state, qubits, shots)
          samples = samples.append(newSamples)
          0.0
        }
      }

    _out = run()
  }
  samples
}
